# OpenSpec Instructions\r\n\r\nInstructions for AI coding assistants using OpenSpec for spec-driven development.\r\n\r\n## TL;DR Quick Checklist\r\n\r\n- Search existing work: `openspec spec list --long`, `openspec list` (use `rg` only for full-text search)\r\n- Decide scope: new capability vs modify existing capability\r\n- Pick a unique `change-id`: kebab-case, verb-led (`add-`, `update-`, `remove-`, `refactor-`)\r\n- Scaffold: `proposal.md`, `tasks.md`, `design.md` (only if needed), and delta specs per affected capability\r\n- Write deltas: use `## ADDED|MODIFIED|REMOVED|RENAMED Requirements`; include at least one `#### Scenario:` per requirement\r\n- Validate: `openspec validate [change-id] --strict` and fix issues\r\n- Request approval: Do not start implementation until proposal is approved\r\n\r\n## Three-Stage Workflow\r\n\r\n### Stage 1: Creating Changes\r\nCreate proposal when you need to:\r\n- Add features or functionality\r\n- Make breaking changes (API, schema)\r\n- Change architecture or patterns  \r\n- Optimize performance (changes behavior)\r\n- Update security patterns\r\n\r\nTriggers (examples):\r\n- "Help me create a change proposal"\r\n- "Help me plan a change"\r\n- "Help me create a proposal"\r\n- "I want to create a spec proposal"\r\n- "I want to create a spec"\r\n\r\nLoose matching guidance:\r\n- Contains one of: `proposal`, `change`, `spec`\r\n- With one of: `create`, `plan`, `make`, `start`, `help`\r\n\r\nSkip proposal for:\r\n- Bug fixes (restore intended behavior)\r\n- Typos, formatting, comments\r\n- Dependency updates (non-breaking)\r\n- Configuration changes\r\n- Tests for existing behavior\r\n\r\n**Workflow**\r\n1. Review `openspec/project.md`, `openspec list`, and `openspec list --specs` to understand current context.\r\n2. Choose a unique verb-led `change-id` and scaffold `proposal.md`, `tasks.md`, optional `design.md`, and spec deltas under `openspec/changes/<id>/`.\r\n3. Draft spec deltas using `## ADDED|MODIFIED|REMOVED Requirements` with at least one `#### Scenario:` per requirement.\r\n4. Run `openspec validate <id> --strict` and resolve any issues before sharing the proposal.\r\n\r\n### Stage 2: Implementing Changes\r\nTrack these steps as TODOs and complete them one by one.\r\n1. **Read proposal.md** - Understand what's being built\r\n2. **Read design.md** (if exists) - Review technical decisions\r\n3. **Read tasks.md** - Get implementation checklist\r\n4. **Implement tasks sequentially** - Complete in order\r\n5. **Confirm completion** - Ensure every item in `tasks.md` is finished before updating statuses\r\n6. **Update checklist** - After all work is done, set every task to `- [x]` so the list reflects reality\r\n7. **Approval gate** - Do not start implementation until the proposal is reviewed and approved\r\n\r\n### Stage 3: Archiving Changes\r\nAfter deployment, create separate PR to:\r\n- Move `changes/[name]/` 鈫?`changes/archive/YYYY-MM-DD-[name]/`\r\n- Update `specs/` if capabilities changed\r\n- Use `openspec archive <change-id> --skip-specs --yes` for tooling-only changes (always pass the change ID explicitly)\r\n- Run `openspec validate --strict` to confirm the archived change passes checks\r\n\r\n## Before Any Task\r\n\r\n**Context Checklist:**\r\n- [ ] Read relevant specs in `specs/[capability]/spec.md`\r\n- [ ] Check pending changes in `changes/` for conflicts\r\n- [ ] Read `openspec/project.md` for conventions\r\n- [ ] Run `openspec list` to see active changes\r\n- [ ] Run `openspec list --specs` to see existing capabilities\r\n\r\n**Before Creating Specs:**\r\n- Always check if capability already exists\r\n- Prefer modifying existing specs over creating duplicates\r\n- Use `openspec show [spec]` to review current state\r\n- If request is ambiguous, ask 1鈥? clarifying questions before scaffolding\r\n\r\n### Search Guidance\r\n- Enumerate specs: `openspec spec list --long` (or `--json` for scripts)\r\n- Enumerate changes: `openspec list` (or `openspec change list --json` - deprecated but available)\r\n- Show details:\r\n  - Spec: `openspec show <spec-id> --type spec` (use `--json` for filters)\r\n  - Change: `openspec show <change-id> --json --deltas-only`\r\n- Full-text search (use ripgrep): `rg -n "Requirement:|Scenario:" openspec/specs`\r\n\r\n## Quick Start\r\n\r\n### CLI Commands\r\n\r\n```bash\r\n# Essential commands\r\nopenspec list                  # List active changes\r\nopenspec list --specs          # List specifications\r\nopenspec show [item]           # Display change or spec\r\nopenspec validate [item]       # Validate changes or specs\r\nopenspec archive <change-id> [--yes|-y]   # Archive after deployment (add --yes for non-interactive runs)\r\n\r\n# Project management\r\nopenspec init [path]           # Initialize OpenSpec\r\nopenspec update [path]         # Update instruction files\r\n\r\n# Interactive mode\r\nopenspec show                  # Prompts for selection\r\nopenspec validate              # Bulk validation mode\r\n\r\n# Debugging\r\nopenspec show [change] --json --deltas-only\r\nopenspec validate [change] --strict\r\n```\r\n\r\n### Command Flags\r\n\r\n- `--json` - Machine-readable output\r\n- `--type change|spec` - Disambiguate items\r\n- `--strict` - Comprehensive validation\r\n- `--no-interactive` - Disable prompts\r\n- `--skip-specs` - Archive without spec updates\r\n- `--yes`/`-y` - Skip confirmation prompts (non-interactive archive)\r\n\r\n## Directory Structure\r\n\r\n```\r\nopenspec/\r\n鈹溾攢鈹€ project.md              # Project conventions\r\n鈹溾攢鈹€ specs/                  # Current truth - what IS built\r\n鈹?  鈹斺攢鈹€ [capability]/       # Single focused capability\r\n鈹?      鈹溾攢鈹€ spec.md         # Requirements and scenarios\r\n鈹?      鈹斺攢鈹€ design.md       # Technical patterns\r\n鈹溾攢鈹€ changes/                # Proposals - what SHOULD change\r\n鈹?  鈹溾攢鈹€ [change-name]/\r\n鈹?  鈹?  鈹溾攢鈹€ proposal.md     # Why, what, impact\r\n鈹?  鈹?  鈹溾攢鈹€ tasks.md        # Implementation checklist\r\n鈹?  鈹?  鈹溾攢鈹€ design.md       # Technical decisions (optional; see criteria)\r\n鈹?  鈹?  鈹斺攢鈹€ specs/          # Delta changes\r\n鈹?  鈹?      鈹斺攢鈹€ [capability]/\r\n鈹?  鈹?          鈹斺攢鈹€ spec.md # ADDED/MODIFIED/REMOVED\r\n鈹?  鈹斺攢鈹€ archive/            # Completed changes\r\n```\r\n\r\n## Creating Change Proposals\r\n\r\n### Decision Tree\r\n\r\n```\r\nNew request?\r\n鈹溾攢 Bug fix restoring spec behavior? 鈫?Fix directly\r\n鈹溾攢 Typo/format/comment? 鈫?Fix directly  \r\n鈹溾攢 New feature/capability? 鈫?Create proposal\r\n鈹溾攢 Breaking change? 鈫?Create proposal\r\n鈹溾攢 Architecture change? 鈫?Create proposal\r\n鈹斺攢 Unclear? 鈫?Create proposal (safer)\r\n```\r\n\r\n### Proposal Structure\r\n\r\n1. **Create directory:** `changes/[change-id]/` (kebab-case, verb-led, unique)\r\n\r\n2. **Write proposal.md:**\r\n```markdown\r\n# Change: [Brief description of change]\r\n\r\n## Why\r\n[1-2 sentences on problem/opportunity]\r\n\r\n## What Changes\r\n- [Bullet list of changes]\r\n- [Mark breaking changes with **BREAKING**]\r\n\r\n## Impact\r\n- Affected specs: [list capabilities]\r\n- Affected code: [key files/systems]\r\n```\r\n\r\n3. **Create spec deltas:** `specs/[capability]/spec.md`\r\n```markdown\r\n## ADDED Requirements\r\n### Requirement: New Feature\r\nThe system SHALL provide...\r\n\r\n#### Scenario: Success case\r\n- **WHEN** user performs action\r\n- **THEN** expected result\r\n\r\n## MODIFIED Requirements\r\n### Requirement: Existing Feature\r\n[Complete modified requirement]\r\n\r\n## REMOVED Requirements\r\n### Requirement: Old Feature\r\n**Reason**: [Why removing]\r\n**Migration**: [How to handle]\r\n```\r\nIf multiple capabilities are affected, create multiple delta files under `changes/[change-id]/specs/<capability>/spec.md`鈥攐ne per capability.\r\n\r\n4. **Create tasks.md:**\r\n```markdown\r\n## 1. Implementation\r\n- [ ] 1.1 Create database schema\r\n- [ ] 1.2 Implement API endpoint\r\n- [ ] 1.3 Add frontend component\r\n- [ ] 1.4 Write tests\r\n```\r\n\r\n5. **Create design.md when needed:**\r\nCreate `design.md` if any of the following apply; otherwise omit it:\r\n- Cross-cutting change (multiple services/modules) or a new architectural pattern\r\n- New external dependency or significant data model changes\r\n- Security, performance, or migration complexity\r\n- Ambiguity that benefits from technical decisions before coding\r\n\r\nMinimal `design.md` skeleton:\r\n```markdown\r\n## Context\r\n[Background, constraints, stakeholders]\r\n\r\n## Goals / Non-Goals\r\n- Goals: [...]\r\n- Non-Goals: [...]\r\n\r\n## Decisions\r\n- Decision: [What and why]\r\n- Alternatives considered: [Options + rationale]\r\n\r\n## Risks / Trade-offs\r\n- [Risk] 鈫?Mitigation\r\n\r\n## Migration Plan\r\n[Steps, rollback]\r\n\r\n## Open Questions\r\n- [...]\r\n```\r\n\r\n## Spec File Format\r\n\r\n### Critical: Scenario Formatting\r\n\r\n**CORRECT** (use #### headers):\r\n```markdown\r\n#### Scenario: User login success\r\n- **WHEN** valid credentials provided\r\n- **THEN** return JWT token\r\n```\r\n\r\n**WRONG** (don't use bullets or bold):\r\n```markdown\r\n- **Scenario: User login**  鉂?**Scenario**: User login     鉂?### Scenario: User login      鉂?```\r\n\r\nEvery requirement MUST have at least one scenario.\r\n\r\n### Requirement Wording\r\n- Use SHALL/MUST for normative requirements (avoid should/may unless intentionally non-normative)\r\n\r\n### Delta Operations\r\n\r\n- `## ADDED Requirements` - New capabilities\r\n- `## MODIFIED Requirements` - Changed behavior\r\n- `## REMOVED Requirements` - Deprecated features\r\n- `## RENAMED Requirements` - Name changes\r\n\r\nHeaders matched with `trim(header)` - whitespace ignored.\r\n\r\n#### When to use ADDED vs MODIFIED\r\n- ADDED: Introduces a new capability or sub-capability that can stand alone as a requirement. Prefer ADDED when the change is orthogonal (e.g., adding "Slash Command Configuration") rather than altering the semantics of an existing requirement.\r\n- MODIFIED: Changes the behavior, scope, or acceptance criteria of an existing requirement. Always paste the full, updated requirement content (header + all scenarios). The archiver will replace the entire requirement with what you provide here; partial deltas will drop previous details.\r\n- RENAMED: Use when only the name changes. If you also change behavior, use RENAMED (name) plus MODIFIED (content) referencing the new name.\r\n\r\nCommon pitfall: Using MODIFIED to add a new concern without including the previous text. This causes loss of detail at archive time. If you aren鈥檛 explicitly changing the existing requirement, add a new requirement under ADDED instead.\r\n\r\nAuthoring a MODIFIED requirement correctly:\r\n1) Locate the existing requirement in `openspec/specs/<capability>/spec.md`.\r\n2) Copy the entire requirement block (from `### Requirement: ...` through its scenarios).\r\n3) Paste it under `## MODIFIED Requirements` and edit to reflect the new behavior.\r\n4) Ensure the header text matches exactly (whitespace-insensitive) and keep at least one `#### Scenario:`.\r\n\r\nExample for RENAMED:\r\n```markdown\r\n## RENAMED Requirements\r\n- FROM: `### Requirement: Login`\r\n- TO: `### Requirement: User Authentication`\r\n```\r\n\r\n## Troubleshooting\r\n\r\n### Common Errors\r\n\r\n**"Change must have at least one delta"**\r\n- Check `changes/[name]/specs/` exists with .md files\r\n- Verify files have operation prefixes (## ADDED Requirements)\r\n\r\n**"Requirement must have at least one scenario"**\r\n- Check scenarios use `#### Scenario:` format (4 hashtags)\r\n- Don't use bullet points or bold for scenario headers\r\n\r\n**Silent scenario parsing failures**\r\n- Exact format required: `#### Scenario: Name`\r\n- Debug with: `openspec show [change] --json --deltas-only`\r\n\r\n### Validation Tips\r\n\r\n```bash\r\n# Always use strict mode for comprehensive checks\r\nopenspec validate [change] --strict\r\n\r\n# Debug delta parsing\r\nopenspec show [change] --json | jq '.deltas'\r\n\r\n# Check specific requirement\r\nopenspec show [spec] --json -r 1\r\n```\r\n\r\n## Happy Path Script\r\n\r\n```bash\r\n# 1) Explore current state\r\nopenspec spec list --long\r\nopenspec list\r\n# Optional full-text search:\r\n# rg -n "Requirement:|Scenario:" openspec/specs\r\n# rg -n "^#|Requirement:" openspec/changes\r\n\r\n# 2) Choose change id and scaffold\r\nCHANGE=add-two-factor-auth\r\nmkdir -p openspec/changes/$CHANGE/{specs/auth}\r\nprintf "## Why\n...\n\n## What Changes\n- ...\n\n## Impact\n- ...\n" > openspec/changes/$CHANGE/proposal.md\r\nprintf "## 1. Implementation\n- [ ] 1.1 ...\n" > openspec/changes/$CHANGE/tasks.md\r\n\r\n# 3) Add deltas (example)\r\ncat > openspec/changes/$CHANGE/specs/auth/spec.md << 'EOF'\r\n## ADDED Requirements\r\n### Requirement: Two-Factor Authentication\r\nUsers MUST provide a second factor during login.\r\n\r\n#### Scenario: OTP required\r\n- **WHEN** valid credentials are provided\r\n- **THEN** an OTP challenge is required\r\nEOF\r\n\r\n# 4) Validate\r\nopenspec validate $CHANGE --strict\r\n```\r\n\r\n## Multi-Capability Example\r\n\r\n```\r\nopenspec/changes/add-2fa-notify/\r\n鈹溾攢鈹€ proposal.md\r\n鈹溾攢鈹€ tasks.md\r\n鈹斺攢鈹€ specs/\r\n    鈹溾攢鈹€ auth/\r\n    鈹?  鈹斺攢鈹€ spec.md   # ADDED: Two-Factor Authentication\r\n    鈹斺攢鈹€ notifications/\r\n        鈹斺攢鈹€ spec.md   # ADDED: OTP email notification\r\n```\r\n\r\nauth/spec.md\r\n```markdown\r\n## ADDED Requirements\r\n### Requirement: Two-Factor Authentication\r\n...\r\n```\r\n\r\nnotifications/spec.md\r\n```markdown\r\n## ADDED Requirements\r\n### Requirement: OTP Email Notification\r\n...\r\n```\r\n\r\n## Best Practices\r\n\r\n### Simplicity First\r\n- Default to <100 lines of new code\r\n- Single-file implementations until proven insufficient\r\n- Avoid frameworks without clear justification\r\n- Choose boring, proven patterns\r\n\r\n### Complexity Triggers\r\nOnly add complexity with:\r\n- Performance data showing current solution too slow\r\n- Concrete scale requirements (>1000 users, >100MB data)\r\n- Multiple proven use cases requiring abstraction\r\n\r\n### Clear References\r\n- Use `file.ts:42` format for code locations\r\n- Reference specs as `specs/auth/spec.md`\r\n- Link related changes and PRs\r\n\r\n### Capability Naming\r\n- Use verb-noun: `user-auth`, `payment-capture`\r\n- Single purpose per capability\r\n- 10-minute understandability rule\r\n- Split if description needs "AND"\r\n\r\n### Change ID Naming\r\n- Use kebab-case, short and descriptive: `add-two-factor-auth`\r\n- Prefer verb-led prefixes: `add-`, `update-`, `remove-`, `refactor-`\r\n- Ensure uniqueness; if taken, append `-2`, `-3`, etc.\r\n\r\n## Tool Selection Guide\r\n\r\n| Task | Tool | Why |\r\n|------|------|-----|\r\n| Find files by pattern | Glob | Fast pattern matching |\r\n| Search code content | Grep | Optimized regex search |\r\n| Read specific files | Read | Direct file access |\r\n| Explore unknown scope | Task | Multi-step investigation |\r\n\r\n## Error Recovery\r\n\r\n### Change Conflicts\r\n1. Run `openspec list` to see active changes\r\n2. Check for overlapping specs\r\n3. Coordinate with change owners\r\n4. Consider combining proposals\r\n\r\n### Validation Failures\r\n1. Run with `--strict` flag\r\n2. Check JSON output for details\r\n3. Verify spec file format\r\n4. Ensure scenarios properly formatted\r\n\r\n### Missing Context\r\n1. Read project.md first\r\n2. Check related specs\r\n3. Review recent archives\r\n4. Ask for clarification\r\n\r\n## Quick Reference\r\n\r\n### Stage Indicators\r\n- `changes/` - Proposed, not yet built\r\n- `specs/` - Built and deployed\r\n- `archive/` - Completed changes\r\n\r\n### File Purposes\r\n- `proposal.md` - Why and what\r\n- `tasks.md` - Implementation steps\r\n- `design.md` - Technical decisions\r\n- `spec.md` - Requirements and behavior\r\n\r\n### CLI Essentials\r\n```bash\r\nopenspec list              # What's in progress?\r\nopenspec show [item]       # View details\r\nopenspec validate --strict # Is it correct?\r\nopenspec archive <change-id> [--yes|-y]  # Mark complete (add --yes for automation)\r\n```\r\n\r\nRemember: Specs are truth. Changes are proposals. Keep them in sync.\r\n